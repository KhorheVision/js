let username = 'Egor'; // создание переменной

const userYear = 19; // создание константы, которую нельзя менять, также если константа дана в сасос начале, а не вычесляется потом, то имя пишется большими буквами

/* Типы данных:
Числа 1,2,3
Строки, которые записываются '' "" и ``(в данные ковычки можно записывать переменные с помощью записи ${переменная})
Логический тип или boolean (true/false)
null - не созданно
undefinde - нет значения
Symbol - пока не знаю
BigInt - пока не знаю
*/

// typeof() - показывает какой тип данных

// два знака !! превращают в булиновое значение

let mass = []; // создание пустого массива и в него можно поместить объекты, строки, числа и т.д. через запятую. Отсчёт начинается с 0

//массивы не равны друг други даже если у них одинаковые значения внутри


let arrMass = ['1', {},
    [], 25
];
arrMass[0] == '1';
arrMass[2] == []; // сравнение на равенство выдаст в двух случаях true

//Методы массивов
arrMass.push('a'); // добавляет элемент в конец массива
arrMass.pop(); // удаляет последний элемент из массива и возвращает его
arrMass.shift(); // удаляет из массива первый элемент и возвращает его (использовать редко)
arrMass.unshift('a'); // добавляет элемент в начало массива (использовать редко)
arrMass.split(s); // превращает строку в массив, s - разделитель
arrMass.join(s); // превращает массив в строку, s - разделитель
delete arrMass[1]; // удаляет второй элемент, в [] можно указать номер элемнта в массиве который хотим удалить
arrMass.splice(index, count, elem1...); // удалить count элементов, начиная с index и заменить на элементы elem1
arrMass.slice(begin, end); // копирует часть массива с begin до end не включая
arrMass.sort(fn); // сортировка массива. Если не передать функцию сравнения - сортирует элементы как строки
arrMass.reverse(); // меняет порядок элементов на обрптный
arrMass.concat(item1...); // создаёт новый массив, в который копируется элементы из arr, а также item1...

// Методы перепора (почитать про них подробнее)
arrMass.forEach
arrMass.map
arrMass.every / some
arrMass.filter
arrMass.reduce

let arr = {}; //создание пустого объекта. в него можно пометстить другие объекты, строки, числа и т.д. Записывается в виде ключ: значение через запятую

// у объектов есть методы и свойства
//свойства объектов:
let obj = {
    name: 'John'
};
obj.name = 'john';
//методы оюъектов (действия, функции):
let obg = {
    sayName: function () {
        alert('John');
    }
};


// функции
// Функции нужны, чтобы не повторять один и тот же код во многих местах.
function fun() {

} //создание функции (Function Declaration). Создается до начала выполнения скрипта, можно вызвать перед объявлением

let func = function () {

}; //создание функции (Function Expression). Создается только тогда, когда доходит поток кода, можно выхвать только после объявления

let sterl = () => {

}; //создание стрелочно функции

/*
Без фигурных скобок: (...args) => expression – правая сторона выражение: функция выполняет его и возвращает результат.

С фигурными скобками: (...args) => { body } – скобки позволяют нам писать многострочные инструкции внутри функции, но при этом необходимо указывать директиву return, чтобы вернуть какое-либо значение.
*/

//Условия:
if (условие) {
    действие
} else {
    другое действие
} // создание условия при ктором будет выполнены нужные действия, также после if можно продолжить задавать другие условия с помощью else if и уже потом в конце писать просто else если ни одно условине не выполнилось

switch (условие) {
    case 'проверка':
        действие;
        break;
    case 'проверка':
        действие;
        break;
    case 'проверка':
        действие;
        break;
    default:
        действие;
        break;
} //создание условия при ктором, выполянется определенный кейс если совпадают значения, если ни одно значение не найдено будет выполнен код в default

//Циклы

while (условие) {
    код,
    тело цикла
} // создание цикла

do {
    тело цикла
} while (условие); // создание цикла, который хоть раз выполнится

for (начало; условие; шаг) {
    тело цикла,
    действие
} // создание цикла
// Пример
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    alert(i);
}

//Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

document.getElementById(); //поиск элемента по id

document.getElementsByTagName(); //получаем псевдомассив элементов по тегу

document.getElementsByClassName(); //получаем псевдомассив с элементами у которых есть данный класс

document.getElementsByClassName()[0]; // получаем первый элемент из псевдомассива

document.querySelectorAll(); // с помощью данной данной команды получаем пседвомассив в котором можно применить метод forEach, а так же в скобочках можно прописать тэг, класс или id, что найти элементы

document.querySelector(); // получаем первый элемент со страници с данным классом, тэгом или id

переменная.style.инлайнсвойство = параметр; // можжно изменить стили или добавить новые

переменная.style.cssText = `прописываем свойства как в css через ;`; //изменяем и добавляем стили (лучше применять данный способ) И использовать лучше `` чтобы можно было прописывать переменные через ${}

псевдомассив.forEach(item => {
    item.style.cssText = `прописываем свойства как в css через ;`;
}); //перебирает элементы в псевдомассиве и применяет стили к ним

const div = document.createElement('нужный тег'); //позволяет создать нужный тег, который можно будет потом вставить на страницу

div.classList.add('название классов'); //добавляет классы к элементу

document.body.append(div); //добавление элемента в конец. вместо body можно написать другой элемент в который мы хотим добавить новый элемент в конец.
document.body.appendChild(div); //старый способ добавление элемента в конец.

document.body.prepend(div); //добавление элемента в начало. вместо body можно написать другой элемент в который мы хотим добавить новый элемент в начало.

элемент.before(div); //добавляет новый элемент перед элементом

элемент.after(div); //добавляет новый элемент после элемента

элементРодитель.insertBefore(div, перед каким элементом вставить); //старый способ добавления элемента

элемент.remove(); //удаление элемента со страницы
элементРодитель.removeChild(элемент который нужно удалить); //старый способ удаления элемента

элемент.replaceWith(другой элемент); // замена одного элемента на другой элемент. другой элемент перемещается
элементРодитель.replaceChild(элемент на который хотим изменить, элемент который хотим заменить); // старый способ замены одного элемента на другой

div.innerHTML = "прописываем нужную HTML структуру например <h1>Hello</h1>"; // добавляем нужную HTML структуру в созданный элемент
div.textContent = "Текст"; // добавляем нужный текст в созданный элемент

div.insertAdjacentHTML('afterbegin', '<h2>Hello</h2>'); //позволяет вставить данные HTML в нутри элемента в начало
div.insertAdjacentHTML('afterend', '<h2>Hello</h2>'); //позволяет вставить данные HTML после элемента
div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>'); //позволяет вставить данные HTML перед элементом
div.insertAdjacentHTML('beforeend', '<h2>Hello</h2>'); //позволяет вставить данные HTML в нутри элемента в конец


// События или отслеживание событий

const btn = document.querySelector('тэг');
btn.onclick = function () {
    alert('Click');
} //Во время клика на тэг который мы пометстили в переменную btn выполнится функция или какое-то действие (таэке это старый способ) Такой способ лучше не использовать на больших проектах

//addEventListener('название события (их много)', колбэе фкнкция - (event - позволяет получить данные об элементе с которым мы работаем) => {}, также можно добавить третьим аргументом опцию(подробнее здесь https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener) например {once: true}) - добавление обработчика события. преимущество данного способа это назначение нескольких действий на одно событие
const deleteElem = (e) => {
    e.target.remove();
};
btn.addEventListener('click', (event) => {
    console.log(event);
    alert('Click');
});

btns.forEach(btn => {
    btn.addEventListener('clcik', deleteElem);
}); // добавляет событие на каздую кнопку которую мы получили в псевдомассиве

btn.addEventListener('clcik', deleteElem); //также можно функции прописывать отдельно и писать название после события

btn.removeEventListener('clcik', deleteElem); //удаление обработчика события (используется в условиях когда например что-то уже произошло и обработчик события надо удалить)

const link = document.querySelector('a');
link.addEventListener('click', (event) => {
    event.preventDefault(); // Отменяет стандартное поведение браузера. Прописывается в самое начало обрабртчика событий
});


//получение элементов со страницы

console.log(document.body); //получаем элемент body и всё что внутри него
console.log(document.head); //получаем элемент head и всё что внутри него
console.log(document.documentElement); //получаем элемент html и всё что внутри него

console.log(document.body.childNodes); //получение узлов, которые находятся внутри body. перенос строки тоже считается узлом
for (let node of document.body.childNodes) {
    if (node.nodeName == '#text') {
        continue;
    } //позволяет убрать текстовый узел

    console.log(node);
}
console.log(document.body.firstChild); //получение первого узла внутри body
console.log(document.body.lastChild); //получение последнего узла внутри body

console.log(document.body.firstElementChild); //получение первого элемента внутри body
console.log(document.body.lastElementChild); //получение последнего элемента внутри body

console.log(document.querySelector('#current').parentNode); // получение родительского узла относительного элемента, ктоторый прописан перед parentNode

console.log(document.querySelector('#current').parentElement); // получение родительского элемента относительного элемента, ктоторый прописан перед parentNode

console.log(document.querySelector('#current').nextSibling); //Получение следующего узла относительно элемента, который прописан перед nextSibling (сосед снизу)
console.log(document.querySelector('#current').previousSibling); //Получение предыдущий узла относительно элемента, который прописан перед nextSibling (сосед сверху)

console.log(document.querySelector('#current').nextElementSibling); //Получение следующего элемента относительно элемента, который прописан перед nextSibling (сосед снизу)
console.log(document.querySelector('#current').previousElementSibling); //Получение предыдущий элемента относительно элемента, который прописан перед nextSibling (сосед сверху)

// в HTML к тегам можно добавлять data атрибуты. Например data-любое слово которое ассоциируется с данным элементом
console.log(document.querySelector('[data-current="3"]')); //пример получения data атрибута

document.addEventListener('DOMContentLoaded', () => {}); //всегда добавлять в начале и писать внутри неё весь код. Данная строка кода дожидается отрисовки DOM структура(дерева) и только тогда когд js начнёт выполняться


/* classList */

// примеры
const btns = document.querySelectorAll('button');

btns.classList; // возвращает псевдомассив, содержащий все классы элемента.  указывает на HTML элемент на котором сработало событие.
btns[0].classList.length; // узнаём сколько классов у элемента
btns[0].classList.item(сюда пишем индекс); // позволяет узнать класс под определенным индексом
btns[0].classList.add('название класса', 'название класса'); // позволяет добавить класс к элементу
btns[0].classList.remove('название класса', 'название класса'); // удаляет класс у элемента
btns[0].classList.toggle('название класса'); // если у элемента нет класса то он его добавит, а если есть то удалит. используется часто с событием click
btns[0].classList.contains('название класса'); //позволяет узнать если ли у элемента такой класс. выводит boolean значение. Используется часто в условиях
if (btns[1].classList.contains('название класса')) {
    console.log('red');
} // например если есть такой класс у элемента то выполняется какое-нибудь действие на странице

btns[0].addEventListener('click', () => {
    // if (!btns[1].classList.contains('red')) {
    //     btns[1].classList.add('red');
    // } else {
    //     btns[1].classList.remove('red');
    // }
    btns[1].classList.toggle('red'); // в сложных скриптах используется не всегда
}); //если у элемента нет класса то при клике на него он добавиться, если такой класс есть то удалится

btns[0].className; // показывает в строчку какие классы есть у элемента. Не использовать в работе.

/* ДЕЛЕГИРОВАНИЕ СОБЫТИЙ */

//обработчик события назначаем родителю, а внутри пороверяем на что кликнули. функцию назначаем для его потомков если они подходят под определенные параметры

const btns = document.querySelectorAll('button');
const wrapper = document.querySelector('btn-block');

wrapper.addEventListener('click', (event) => {
    if (event.target && evant.target.classList.contains('red')) {
        console.log('red');
    } // event.target прописываем всегда чтобы скрипт выполнялся всегда и не выдавал ошибку. Можно проверять не только класс
});
wrapper.addEventListener('click', (event) => {
    if (event.target && evant.target.matches('button.red')) {
        console.log('hello go');
    } // evant.target.matches('button.red') - проверяем что элемент button с классом red совпадает с тем, что нам нужно чтобы выполнить скрипт
});


/* АСИНХРОННОСТЬ */

const timeout = setTimeout(() => {
    console.log('After timeout')
}, 2500) // принимает 2 параметра: функцию и через какое время в милисикундах будет выполнена.
const timeout = setTimeout((text) => {
    console.log(text)
}, 2500, 'Hello') // Елси функция принимает какие-то переменные то их можно будет прописать через запятую после назначения времени

clearTimeout(timeout) // очищает таймаут если не хотим чтобы он выполнялся

const interval = setInterval(() => {
    console.log('After timeout')
}, 2500) // принимает 2 параметра: функцию и через какое время в милисикундах будет повторятся выполнение функции. часто используется для анимации

clearInterval(interval) // останавливает и очищает интервал если не хотим чтобы он выполнялся

/* ДАТА */

const now = new Date();
console.log(now); // показывает какое сейчас время и какая сейчас дата

const now = new Date('2020-05-01'); // позволяет передать нужную дату в строчку и получить её, но время будет 00:00:00.000

const now = new Date(2020, 5, 1, 20); // токой записью позволяет передать нужную дату (год, месяц, число) и время (часы, минуты, секунды, милимекунды) в строчку и получить её
// месяцы считаются с 0 до 11
// дни считаются с 0 до 6, где 0 это воскресенье

const now = new Date(0); // также можно передавать количество миллисекунд. отсчёт начинается с 1 января 1970 года полночь. 0 - выдаёт 1 января 1970 год. чтобы получить год который позже 1970, то надо ввести отрицательное значение

// Часто используемые методы доты

now.getFullYear(); // позволяет получить год
now.getMonth(); // позволяет получить месяц
now.getDate(); // позволяет получить день
now.getHours(); // позволяет получить часы
now.getMinutes(); // позволяет получить минуты
now.getSeconds(); // позволяет получить секунды
now.getMilliseconds(); // позволяет получить милисекунды
now.getDay(); // позволяет получить день недели
// данные методы также можно записать например getUTCHours, и получить время часового пояса +0

now.getTimezoneOffset(); // позволяет получить разницк между часовым поясом, который на компе и UTC+0 поясом. разница будет в минутах

now.getTime(); // позволяет получить число милисекунд, которое прошло с 1 января 1970 года.

//Чтобы изменить дату в методах выше кроме getTimezoneOffset, надо вместо get написать set
now.setHours(40); // проиходит автоисправление, если введено больше стандарта

// небольшой пример, который покажет сколько милисекунд выполняется цикл
let start = new Date(); // помещаем текущее время

for (let i = 0; i < 100000; i++) {
    let some = i ** 3; // возводим в 3 степень
}

let end = new Date(); // помещаем следующее текущее время после цикла

console.log(`Время выполнения цикла равно ${end - start} миллисекунд`);

Date.parse(переменная или дата); // разбирает строковое представление даты и возвращает количество миллисекунд прошедших с 1 января 1970 года 00:00:00 по UTC.

/* window, document */

const box = document.querySelector('.box');

// получаем ширину и высоту без учёта margin, border, scroll. показывают только видимую часть
box.clientWidth;
box.clientHeight;

// получаем ширину и высоту c учётом margin, padding, border, scroll. показывают только видимую часть
box.offsetWidth;
box.offsetHeight;

// получаем полность ширину и высоту элемента без учёта панелей scroll
box.scrollWidth;
const heigth = box.scrollHeight;

//вместо элемента можно прописать например document.documentElement.scrollHeight и мы получим высоту всего документа


btn.addEventListener('click', () => {
    box.style.heigth = heigth + 'px';
}); // при клике на кнопку раскрывает элемент полностью на всю высоту.

btn.addEventListener('click', () => {
    console.log(box.scrollTop);
}); // при клике на кнопку показывает сколько прокрутили от начала страницы

box.getBoundingClientRect(); //позволяет получить все коордунаты которые есть у элемента

const style = window.getComputedStyle(box); // позволяет получить все стили, которые установленны(применились) на данный элемент

window.scrollBy(x, y); // позволяет скроллить страницу относительно текущего положения
window.scrollTo(x, y); // позволяет скроллить страницу относительно начала страницы

window.pageYOffset; //позволяет понять сколько пикселей отличстал пользователь с начала страницы


/* Функции-конструкторы ES5*/

// Функции-конструкторы или конструкторы нужны для того чтобы создавать новые однотипные объекты. В пракике это могут быть например пользователи сайта, товары в магазине, видеоролики, компоненты сайта (слайдет и т.д.)
//Пример
function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello = function () {
        console.log(`Привет ${this.name}`);
    }
} // функция конструктор, которая поможет создавать разные объекты по этому шаблону. Имя Функции-конструктора всегда пишется с большой буквы. Также можешм прописывать методы

User.prototype.exit = function () {
    console.log(`Пользоваетль ${this.name} вышел`);
} // Также позвоялет задать новый метод Функции-конструктор через прототип, который смогуть использовать созданные объекты.

const ivan = new User('Ivan', 12);
const elena = new User('Elena', 25); // поместили в переменную новый объект с свойстави которые написаны в Функции-конструктор. Чтобы вызвать Функции-конструктор, надо писать new название Функции-конструктора, и передать нужные значения в функцию

ivan.exit(); // вызвваем метод, который прописали в прототипе

ivan.hello(); // вызываем метод, который был прописан в Функции-конструктора

/* Конетекст вызова. this */

function showThis() {
    console.log(this);
} // данная функция выдалст window если нет режима strict, если есть то выдаст undefined так как this должна привязываться к объекту, а функция должна быть его методом
// Обычная функция: this = window, но если use strict- undefined

function showThis(a, b) {
    console.log(this);

    function sum() {
        return this.a + this.b;
    }
} // если используется функция внутри функции то контекст не меняется и this будет равен undefined

const obj = {
    a: 20,
    b: 15,
    sum: function () {
        console.log(this); // выдаст весь объект
        function shout() {
            console.log(this);
        }
        shout(); // так как это простой вызов функции, то this выдаст undefined
    }
}
// Если используем метод внутри объекта, то this(контекст вызова) будет всегда ссылаться на объект
// Контекст у методов объекта - сам объект

function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello = function () {
        console.log(`Привет ${this.name}`);
    }
}

const egor = new User('Egor', 25);

// внутри функкции конструктора контекст вызова(this) всех методов и свойств будет только что созданный объект
// this в конструкторах и классах - это новый экземпляо объекта

//Ручное присвоение this любой функции
//Пример. Получение доступа к name для функции
function sayName() {
    console.log(this);
    console.log(this.name);
}

const user = {
    name: 'Jhon'
};

// разница только в синтаксисе, а так выдают тоже самое
sayName.call(user); // в скобках передаем контекст вызова который хотим передать функции
sayName.apply(user); // в скобках передаем контекст вызова который хотим передать функции
// функция приобрела свой контекст с помощью двух методов кторые записаны выше
// Если функция принимает дополнительные аргументы то запись становится такой:
sayName.call(user, 'аргумент', 'аргумент'); // аргументы передаются через запятую
sayName.apply(user, ['аргумент', 'аргумент']); // аргументы передаются в массиве через запятую

function count(num) {
    return this * num;
}
const double = count.bind(2); // передаем в контекст вызова 2. т.е. вместо this у нас будет 2. Так мы получаем новую функцию у которой жестко привязаный контекст
bind(); // создает новую функцию связанную с определенным контекстом
console.log(double(3)); // высываем функцию и передаем ей аргумент num. во время вызова функция выполнит действие: 2 * 3. так как this у нас 2
// ручная привязка this: call, apply, bind


btn.addEventListener('click', function () {
    console.log(this);
}); // при клике получем элемент на который кликнули. в данному случае на кнопку. Но это если функция написана в стандартном виде, т.е. не стрелочная. this здесь тоже самое, что и event.target

// у стрелочных функций нет своего контекста вызова, она его берет у родителя
const obj = {
    num: 5,
    sayNamber: function () {
        const say = () => {
            console.log(this); // в данном случае this будет ссылаться на объект, так как используем стрелочную функцию. в итоге выведет объект
        };

        say();
    }
}

btn.addEventListener('click', () => {
    console.log(this);
}); // если обработчике событий будет использовать стрелочную функцию, то this будет undefined. Использую стрелочные функции контект события теряется. Если в обработчике событий используем стрелочные функции, то лучше передавать аргумент event и не использовать this

/* Классы - это Синтаксический сахар */
// Классы красивая обёртка функции-костроктора
// часто используются для создания шаблонов
class Rectangle {
    constructor(height, width) {
        this.heigth = height;
        this.width = width;
    } // запятые в классе ставить не надо

    calcArea() {
        return this.heigth * this.width;
    }
}
// чтобы создать класс надо написать: class имяКласс {методы и свойста класса}
// чтобы в классе прописать свойста нужно написать так: constructor(аргументы, которые например могут приходить из вне) {здесь пишем свойства}
// методы пишутся: названиеМетода() {код} . Перед названием не надо писать function

class ColoredRectanglWidthText extends Rectangle {
    constructor(height, width, text, bgColor) {
        super(); // позволяет не прописывать заного свойства класса от которого наследуется данный класс. В общем получаем все свойста класса от которого наследуется данный класс и ниже можно дальше писать свойста для данного класса. всегда должен быть первым.
        this.text = text;
        this.bgColor = bgColor;
    }

    showMyPrors() {
        console.log(`текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}
// extends - позволяяет наследовать и использовать свойства и методы другого класса

/* Rest оператор и параметры по умолчанию */

const log = function (a, b = 1, ...rest) {
    console.log(a, b, rest);
} // ...rest - это возможные другие аргументы которых может быть очень много и возвращаются они в ввиде одно массива. даже если небыло введено ни одно другого аргумента после основных, то всё равно веренет массив, только пустой
// также аргументам мы можем задавать значения по умолчанию. в ES6 это делатется так: аргумент = значение по умолчанию. В ES5 делали присваивание с или: b = b || 1

/* JSON */

// json - используется для передачи и хранения данных
// json - это набор пар ключ: значение как и в объекте
// своего рода это небольшая База данных

const persone = {
    name: 'Alex',
    tel: '+744444444'
}
//напирмер нам надо передать данный объект на сервер. На прямую мы отправить не можем так как сервер и протокол передачи данных просто не поймут, поэтому надо превратить в один из вариантов чтобы можно было его транспортировать(передать)

JSON.stringify(persone); // преобразует в строку JSON, чтобы можно было передать на сервер и чтобы он понял что передали
// в json всё записано в парные кавычки

JSON.parse(JSON.stringify(persone)); // преобразует строку JSON, например которая пришла с сервера в обычный объект с которым можно дальше работать в JS

const clone = JSON.parse(JSON.stringify(persone)); // позволяет сделать полную копию объекта, т.е. копирует так же все вложенности которые есть в объекте. методы не копирует

/* AJAX. Общение с сервером */

const inputRub = document.querySelector('#rub');
const inputUsd = document.querySelector('#usd');

inputRub.addEventListener('input', () => {
    const request = new XMLHttpRequest(); // создаём XMLHttpRequest-объект

    request.open(method, url, asyns, login, pass); // вызвваем метод open(). собирает настройки, которые нужны для отправки запроса. принимает в себя несколько аргументов. 1) метод запроса (самые популярные GET и POST) GET - это получение данных. POST - отправка данных. 2) путь к серверу (может быть например файлик). Прописываем url по которому будем делать запрос. 3) отвечает на асинхронность. по умолчанию true. 4) некоторые запросы можно делать только если знаешь логин и пароль
    request.open('GET', 'js/current.json');
    // HTTP-заголовки -- позволяет сказать, что конкретно мы отправляем. какая информация, в чём закодирована. Делается для того чтобы трансферные протоколы понимали, что они передают и когда они предут с серверу, сервер точно понимал, что он принимает. (например это JSON файл, картинка, html и т.д.)
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); // заголовок который позволяет отправить json файл. Внутри указываем тип контента (в нашем случаем для json файла), плюс кодировку которую используем.
    request.send(); // метод который позволяет сделать отправку запроса на сервер. если используем метод GET то в скобачках ничего не пишем. Если будем использовать метод POST, то можно прописать тело запроса.

    // status - показывает статус нашего запроса (список кодов: https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
    // statusText - текстовое описание ответа от сервера
    // response - ответ от сервера
    // readyState - текущее состояние нашего запроса (https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState)

    request.addEventListener('readystatechange', () => { // readystatechange - используется редко
        if (request.readyState === 4 && request.status === 200) {
            console.log(request.response); // покажет, что пришло с сервера. тоесть результат запроса (объект json, который надо будет перевести в обычный объект, чтобы использовать), когда мы вводим, что-то в input
            const data = JSON.parse(request.response); // json-объект переводим в обычный объект, который можно использовать
            inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); // вычисляем значения
        } // если статус готовности равен 4 (тоесть Операция полностью завершена и все данные пришли) и статус ответа равен 200 (тоесть ОК - хорошо, запрос успешно завершился). Можем выполнять действия на странице с данными которые пришли с сервера. Но перед этим первратить данные в обычные объекты
        else {
            inputUsd.value = 'Что-то пошло не так';
        } //всегда лучше показыавть, что пошло что-то не так. чтобы клиент например перезагрузил страницу и не ждал долго ответа
    }); // отслеживает собития статуса готовности нашего запроса в данный текущий момент. Следит за readyState

    // используем load
    request.addEventListener('load', () => { // load - страбатывает только один раз, когда запрос уже полность готов
        if (request.status === 200) {
            const data = JSON.parse(request.response);
            inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2);
        } else {
            inputUsd.value = 'Что-то пошло не так';
        }
    }); // отслеживает собития статуса готовности нашего запроса в данный текущий момент. Следит за readyState


}); // используем обработчик событий input, который позволяет сразу считывать введённую информацию в input. Получаем нужную инвормацию с сервера и используем её.
// XMLHttpRequest это API, который предоставляет клиенту функциональность для обмена данными между клиентом и сервером.


/* Промисы (Promise)(Обещание) */

console.log('Запрос данных...');

// callback hell
setTimeout(() => {
    console.log('Подготовка данных...');

    const product = {
        name: TV,
        price: 2000
    };

    setTimeout(() => {
        product.status = 'order';
        console.log(product)
    }, 2000);
}, 2000);
// чтобы не попадать в callback hell, нужно использовать промисы
// промисы позволяют улучшить порядок кода и дают нам гибкость

console.log('Запрос данных...');

const req = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('Подготовка данных...');

        const product = {
            name: TV,
            price: 2000
        };
        // например мы получаем через 2 секунды объект и строку 'Подготовка данных...'. после этого выполняется resolve();
        resolve(product);
    }, 2000);
}); // колбек функция всегда принимает 2 аргумента, resolve и reject
// resolve означает, что что-то выполнилось правильно и отдаёт результат. Если сервер ответил то выполняется resolve()
// reject означает, что что-то пошло не так и выдаёт ошибку или ошибки. Если сервер не ответил или ответил с ошибкой, тоесть что-то пошло не так, то выполняется reject()
req.then((product) => {
    console.log('Данные получены');
    setTimeout(() => {
        product.status = 'order';
        console.log(product);
    }, 2000);
}); // Выполняется когда при выполнении промиса небыло ошибок и он выдал определенный результат и мы его передали сюда
// then(() => {}) обрабатывает положительные результаты. принимает аргумент с функцией, который называется resolve

// Допустим, что нужно сделать ещё несколько действий
req.then((product) => {
    const req2 = new Promise((resolve, reject) => {
        console.log('Данные получены');
        setTimeout(() => {
            product.status = 'order';
            resolve(product);
        }, 2000);
    });

    req2.then(data => {
        console.log(data);
    });
}); // данная запись не сильно отличается от callback hell

// преимущества промисов в том, что они могут промис then по цепочке. Асинхронная операция выполниться и начнётся следующая, которая будет использовать данные из результата прошлой или просто начнёт делать что-то другое
req.then((product) => { // принимает например данные от сервера
    return new Promise((resolve, reject) => { // возвращаем новый промис
        console.log('Данные получены');
        setTimeout(() => {
            product.status = 'order';
            resolve(product);
            // reject(); // будет выполняться если произошла ошибка
        }, 2000); // возвращаем промис, который выполнил асинхронную операцию. в итоге когда всё успешно мы выхываем resolve и возвращаем данные, которые пойдут дальше по операциям
    });
}).then(data => { // обробатываем любыми методами данные которые передал прошлый промис
    data.modify = true; // возвращать можем не только промисы
    return data;
}).then(data => {
    console.log(data); // если например опять надо будет работать с какой-то асинхронной операцией, то мы вернём от сюда промис и дальше его обработаем
}).catch(() => { // catch прописывается всегда в конце и выполниться если будет какая-то ошибка при выполнении
    console.error('Произошла ошибка');
}).finally(() => { // finally выполняется всегда. даже если вернулась ошибка
    console.log('Finally');
});
// с помощью промисов мы можем выполнять асинхронные операции по цепочке

const test = time => {
    return new Promise(resolve => {
        setTimeout(() => resolve(), time);
    });
}; // функция которая принимает количество времени, возвращает промис, который зарезолвится через определенное количество времени, которое мы передаем в эту функцию. Такую функцию можно использовать чтобы запускать одинаковые операции через определенный промежуток времени
test(1000).then(() => console.log('1000 ms')); // через 1 сек. покажет сообщение в консоле
test(2000).then(() => console.log('2000 ms')); // через 1 сек. покажет сообщение в консоле

Promise.all([test(1000), test(2000)]).then(() => {
    console.log('All');
}); // Данный метод принимает массив с промисами. Он ждет когда все промисы которые находятся в массиве выполнятся. После того как они вернут результат мы може его обработать

Promise.race([test(1000), test(2000)]).then(() => {
    console.log('All');
}); // Данный метод исполняется, когда хоть 1 промис выполнился (правильно отработал)


/* Fetch API */

// API - интерфейс какого-то праграмного обеспечения, либо приложения. Проще это набор данных и возможностей, которое предоставляет нам готовое решение.
// API — это не готовые решения, это среда, интерфейс для создания своих проектов. 
// API — это готовый код для упрощения жизни программисту. API создавался для того, чтобы программист реально мог облегчить задачу написания того или иного приложения благодаря использованию готового кода (например, функций).

// Fetch API - помогает общаться с сервером и постоена на промисах

fetch();

fetch('https://jsonplaceholder.typicode.com/todos/1') // делаем запрос. прописываем url куда делаем запрос. если больше ничего не указывать то это будет GET запрос. Возвращается промис
    .then(response => response.json()) // получает http-ответ и декодирует ответ в формате JSON. в итоге получаем промис, где значением будет обычный объект
    .then(json => console.log(json)); // выводим в консоль объект, который пришел с сервера

fetch('https://jsonplaceholder.typicode.com/posts/1', {
        method: 'POST',
        body: JSON.stringify({
            name: 'Alex'
        }), // в данном случае отправляем json данные. кроме объекста также можем поместить строку
        headers: {
            'Content-type': 'application/json'
        } // заголовки, чтобы определить какой контент мы отправляем
    }) // чтобы отправить запрос, нужно прописать url и объект в котороем есть несколько настроек, которые позволяют отправить запрос. в этом объеекте есть 2 обязаательных свойства: method и body(тело которое будем отправлять)
    .then(response => response.json()) // получает http-ответ и декодирует ответ в формате JSON. в итоге получаем промис, где значением будет обычный объект
    .then(json => console.log(json)); // выводим в консоль объект, который пришел с сервера