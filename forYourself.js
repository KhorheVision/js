let username = 'Egor'; // создание переменной

const userYear = 19; // создание константы, которую нельзя менять, также если константа дана в сасос начале, а не вычесляется потом, то имя пишется большими буквами

/* Типы данных:
Числа 1,2,3
Строки, которые записываются '' "" и ``(в данные ковычки можно записывать переменные с помощью записи ${переменная})
Логический тип или boolean (true/false)
null - не созданно
undefinde - нет значения
Symbol - пока не знаю
BigInt - пока не знаю
*/

// typeof() - показывает какой тип данных

// два знака !! превращают в булиновое значение

let mass = []; // создание пустого массива и в него можно поместить объекты, строки, числа и т.д. через запятую. Отсчёт начинается с 0

//массивы не равны друг други даже если у них одинаковые значения внутри


let arrMass = ['1', {},
    [], 25
];
arrMass[0] == '1';
arrMass[2] == []; // сравнение на равенство выдаст в двух случаях true

//Методы массивов
arrMass.push('a'); // добавляет элемент в конец массива
arrMass.pop(); // удаляет последний элемент из массива и возвращает его
arrMass.shift(); // удаляет из массива первый элемент и возвращает его (использовать редко)
arrMass.unshift('a'); // добавляет элемент в начало массива (использовать редко)
arrMass.split(s); // превращает строку в массив, s - разделитель
arrMass.join(s); // превращает массив в строку, s - разделитель
delete arrMass[1]; // удаляет второй элемент, в [] можно указать номер элемнта в массиве который хотим удалить
arrMass.splice(index, count, elem1...); // удалить count элементов, начиная с index и заменить на элементы elem1
arrMass.slice(begin, end); // копирует часть массива с begin до end не включая
arrMass.sort(fn); // сортировка массива. Если не передать функцию сравнения - сортирует элементы как строки
arrMass.reverse(); // меняет порядок элементов на обрптный
arrMass.concat(item1...); // создаёт новый массив, в который копируется элементы из arr, а также item1...

// Методы перепора (почитать про них подробнее)
arrMass.forEach
arrMass.map
arrMass.every / some
arrMass.filter
arrMass.reduce

let arr = {}; //создание пустого объекта. в него можно пометстить другие объекты, строки, числа и т.д. Записывается в виде ключ: значение через запятую

// у объектов есть методы и свойства
//свойства объектов:
let obj = {
    name: 'John'
};
obj.name = 'john';
//методы оюъектов (действия, функции):
let obg = {
    sayName: function () {
        alert('John');
    }
};


// функции
// Функции нужны, чтобы не повторять один и тот же код во многих местах.
function fun() {

} //создание функции (Function Declaration). Создается до начала выполнения скрипта, можно вызвать перед объявлением

let func = function () {

}; //создание функции (Function Expression). Создается только тогда, когда доходит поток кода, можно выхвать только после объявления

let sterl = () => {

}; //создание стрелочно функции

/*
Без фигурных скобок: (...args) => expression – правая сторона выражение: функция выполняет его и возвращает результат.

С фигурными скобками: (...args) => { body } – скобки позволяют нам писать многострочные инструкции внутри функции, но при этом необходимо указывать директиву return, чтобы вернуть какое-либо значение.
*/

//Условия:
if (условие) {
    действие
} else {
    другое действие
} // создание условия при ктором будет выполнены нужные действия, также после if можно продолжить задавать другие условия с помощью else if и уже потом в конце писать просто else если ни одно условине не выполнилось

switch (условие) {
    case 'проверка':
        действие;
        break;
    case 'проверка':
        действие;
        break;
    case 'проверка':
        действие;
        break;
    default:
        действие;
        break;
} //создание условия при ктором, выполянется определенный кейс если совпадают значения, если ни одно значение не найдено будет выполнен код в default

//Циклы

while (условие) {
    код,
    тело цикла
} // создание цикла

do {
    тело цикла
} while (условие); // создание цикла, который хоть раз выполнится

for (начало; условие; шаг) {
    тело цикла,
    действие
} // создание цикла
// Пример
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    alert(i);
}

//Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

document.getElementById(); //поиск элемента по id

document.getElementsByTagName(); //получаем псевдомассив элементов по тегу

document.getElementsByClassName(); //получаем псевдомассив с элементами у которых есть данный класс

document.getElementsByClassName()[0]; // получаем первый элемент из псевдомассива

document.querySelectorAll(); // с помощью данной данной команды получаем пседвомассив в котором можно применить метод forEach, а так же в скобочках можно прописать тэг, класс или id, что найти элементы

document.querySelector(); // получаем первый элемент со страници с данным классом, тэгом или id

переменная.style.инлайнсвойство = параметр; // можжно изменить стили или добавить новые

переменная.style.cssText = `прописываем свойства как в css через ;`; //изменяем и добавляем стили (лучше применять данный способ) И использовать лучше `` чтобы можно было прописывать переменные через ${}

псевдомассив.forEach(item => {
    item.style.cssText = `прописываем свойства как в css через ;`;
}); //перебирает элементы в псевдомассиве и применяет стили к ним

const div = document.createElement('нужный тег'); //позволяет создать нужный тег, который можно будет потом вставить на страницу

div.classList.add('название классов'); //добавляет классы к элементу

document.body.append(div); //добавление элемента в конец. вместо body можно написать другой элемент в который мы хотим добавить новый элемент в конец.
document.body.appendChild(div); //старый способ добавление элемента в конец.

document.body.prepend(div); //добавление элемента в начало. вместо body можно написать другой элемент в который мы хотим добавить новый элемент в начало.

элемент.before(div); //добавляет новый элемент перед элементом

элемент.after(div); //добавляет новый элемент после элемента

элементРодитель.insertBefore(div, перед каким элементом вставить); //старый способ добавления элемента

элемент.remove(); //удаление элемента со страницы
элементРодитель.removeChild(элемент который нужно удалить); //старый способ удаления элемента

элемент.replaceWith(другой элемент); // замена одного элемента на другой элемент. другой элемент перемещается
элементРодитель.replaceChild(элемент на который хотим изменить, элемент который хотим заменить); // старый способ замены одного элемента на другой

div.innerHTML = "прописываем нужную HTML структуру например <h1>Hello</h1>"; // добавляем нужную HTML структуру в созданный элемент
div.textContent = "Текст"; // добавляем нужный текст в созданный элемент

div.insertAdjacentHTML('afterbegin', '<h2>Hello</h2>'); //позволяет вставить данные HTML в нутри элемента в начало
div.insertAdjacentHTML('afterend', '<h2>Hello</h2>'); //позволяет вставить данные HTML после элемента
div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>'); //позволяет вставить данные HTML перед элементом
div.insertAdjacentHTML('beforeend', '<h2>Hello</h2>'); //позволяет вставить данные HTML в нутри элемента в конец


// События или отслеживание событий

const btn = document.querySelector('тэг');
btn.onclick = function () {
    alert('Click');
} //Во время клика на тэг который мы пометстили в переменную btn выполнится функция или какое-то действие (таэке это старый способ) Такой способ лучше не использовать на больших проектах

//addEventListener('название события (их много)', колбэе фкнкция - (event - позволяет получить данные об элементе с которым мы работаем) => {}, также можно добавить третьим аргументом опцию(подробнее здесь https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener) например {once: true}) - добавление обработчика события. преимущество данного способа это назначение нескольких действий на одно событие
const deleteElem = (e) => {
    e.target.remove();
};
btn.addEventListener('click', (event) => {
    console.log(event);
    alert('Click');
});

btns.forEach(btn => {
    btn.addEventListener('clcik', deleteElem);
}); // добавляет событие на каздую кнопку которую мы получили в псевдомассиве

btn.addEventListener('clcik', deleteElem); //также можно функции прописывать отдельно и писать название после события

btn.removeEventListener('clcik', deleteElem); //удаление обработчика события (используется в условиях когда например что-то уже произошло и обработчик события надо удалить)

const link = document.querySelector('a');
link.addEventListener('click', (event) => {
    event.preventDefault(); // Отменяет стандартное поведение браузера. Прописывается в самое начало обрабртчика событий
});


//получение элементов со страницы

console.log(document.body); //получаем элемент body и всё что внутри него
console.log(document.head); //получаем элемент head и всё что внутри него
console.log(document.documentElement); //получаем элемент html и всё что внутри него

console.log(document.body.childNodes); //получение узлов, которые находятся внутри body. перенос строки тоже считается узлом
for (let node of document.body.childNodes) {
    if (node.nodeName == '#text') {
        continue;
    } //позволяет убрать текстовый узел

    console.log(node);
}
console.log(document.body.firstChild); //получение первого узла внутри body
console.log(document.body.lastChild); //получение последнего узла внутри body

console.log(document.body.firstElementChild); //получение первого элемента внутри body
console.log(document.body.lastElementChild); //получение последнего элемента внутри body

console.log(document.querySelector('#current').parentNode); // получение родительского узла относительного элемента, ктоторый прописан перед parentNode

console.log(document.querySelector('#current').parentElement); // получение родительского элемента относительного элемента, ктоторый прописан перед parentNode

console.log(document.querySelector('#current').nextSibling); //Получение следующего узла относительно элемента, который прописан перед nextSibling (сосед снизу)
console.log(document.querySelector('#current').previousSibling); //Получение предыдущий узла относительно элемента, который прописан перед nextSibling (сосед сверху)

console.log(document.querySelector('#current').nextElementSibling); //Получение следующего элемента относительно элемента, который прописан перед nextSibling (сосед снизу)
console.log(document.querySelector('#current').previousElementSibling); //Получение предыдущий элемента относительно элемента, который прописан перед nextSibling (сосед сверху)

// в HTML к тегам можно добавлять data атрибуты. Например data-любое слово которое ассоциируется с данным элементом
console.log(document.querySelector('[data-current="3"]')); //пример получения data атрибута

document.addEventListener('DOMContentLoaded', () => {}); //всегда добавлять в начале и писать внутри неё весь код. Данная строка кода дожидается отрисовки DOM структура(дерева) и только тогда когд js начнёт выполняться


/* classList */

// примеры
const btns = document.querySelectorAll('button');

btns.classList; // возвращает псевдомассив, содержащий все классы элемента.  указывает на HTML элемент на котором сработало событие.
btns[0].classList.length; // узнаём сколько классов у элемента
btns[0].classList.item(сюда пишем индекс); // позволяет узнать класс под определенным индексом
btns[0].classList.add('название класса', 'название класса'); // позволяет добавить класс к элементу
btns[0].classList.remove('название класса', 'название класса'); // удаляет класс у элемента
btns[0].classList.toggle('название класса'); // если у элемента нет класса то он его добавит, а если есть то удалит. используется часто с событием click
btns[0].classList.contains('название класса'); //позволяет узнать если ли у элемента такой класс. выводит boolean значение. Используется часто в условиях
if (btns[1].classList.contains('название класса')) {
    console.log('red');
} // например если есть такой класс у элемента то выполняется какое-нибудь действие на странице

btns[0].addEventListener('click', () => {
    // if (!btns[1].classList.contains('red')) {
    //     btns[1].classList.add('red');
    // } else {
    //     btns[1].classList.remove('red');
    // }
    btns[1].classList.toggle('red'); // в сложных скриптах используется не всегда
}); //если у элемента нет класса то при клике на него он добавиться, если такой класс есть то удалится

btns[0].className; // показывает в строчку какие классы есть у элемента. Не использовать в работе.

/* ДЕЛЕГИРОВАНИЕ СОБЫТИЙ */

//обработчик события назначаем родителю, а внутри пороверяем на что кликнули. функцию назначаем для его потомков если они подходят под определенные параметры

const btns = document.querySelectorAll('button');
const wrapper = document.querySelector('btn-block');

wrapper.addEventListener('click', (event) => {
    if (event.target && evant.target.classList.contains('red')) {
        console.log('red');
    } // event.target прописываем всегда чтобы скрипт выполнялся всегда и не выдавал ошибку. Можно проверять не только класс
});
wrapper.addEventListener('click', (event) => {
    if (event.target && evant.target.matches('button.red')) {
        console.log('hello go');
    } // evant.target.matches('button.red') - проверяем что элемент button с классом red совпадает с тем, что нам нужно чтобы выполнить скрипт
});


/* АСИНХРОННОСТЬ */

const timeout = setTimeout(() => {
    console.log('After timeout')
}, 2500) // принимает 2 параметра: функцию и через какое время в милисикундах будет выполнена.
const timeout = setTimeout((text) => {
    console.log(text)
}, 2500, 'Hello') // Елси функция принимает какие-то переменные то их можно будет прописать через запятую после назначения времени

clearTimeout(timeout) // очищает таймаут если не хотим чтобы он выполнялся

const interval = setInterval(() => {
    console.log('After timeout')
}, 2500) // принимает 2 параметра: функцию и через какое время в милисикундах будет повторятся выполнение функции. часто используется для анимации

clearInterval(interval) // останавливает и очищает интервал если не хотим чтобы он выполнялся

/* ДАТА */

const now = new Date();
console.log(now); // показывает какое сейчас время и какая сейчас дата

const now = new Date('2020-05-01'); // позволяет передать нужную дату в строчку и получить её, но время будет 00:00:00.000

const now = new Date(2020, 5, 1, 20); // токой записью позволяет передать нужную дату (год, месяц, число) и время (часы, минуты, секунды, милимекунды) в строчку и получить её
// месяцы считаются с 0 до 11
// дни считаются с 0 до 6, где 0 это воскресенье

const now = new Date(0); // также можно передавать количество миллисекунд. отсчёт начинается с 1 января 1970 года полночь. 0 - выдаёт 1 января 1970 год. чтобы получить год который позже 1970, то надо ввести отрицательное значение

// Часто используемые методы доты

now.getFullYear(); // позволяет получить год
now.getMonth(); // позволяет получить месяц
now.getDate(); // позволяет получить день
now.getHours(); // позволяет получить часы
now.getMinutes(); // позволяет получить минуты
now.getSeconds(); // позволяет получить секунды
now.getMilliseconds(); // позволяет получить милисекунды
now.getDay(); // позволяет получить день недели
// данные методы также можно записать например getUTCHours, и получить время часового пояса +0

now.getTimezoneOffset(); // позволяет получить разницк между часовым поясом, который на компе и UTC+0 поясом. разница будет в минутах

now.getTime(); // позволяет получить число милисекунд, которое прошло с 1 января 1970 года.

//Чтобы изменить дату в методах выше кроме getTimezoneOffset, надо вместо get написать set
now.setHours(40); // проиходит автоисправление, если введено больше стандарта

// небольшой пример, который покажет сколько милисекунд выполняется цикл
let start = new Date(); // помещаем текущее время

for (let i = 0; i < 100000; i++) {
    let some = i ** 3; // возводим в 3 степень
}

let end = new Date(); // помещаем следующее текущее время после цикла

console.log(`Время выполнения цикла равно ${end - start} миллисекунд`);

Date.parse(переменная или дата); // разбирает строковое представление даты и возвращает количество миллисекунд прошедших с 1 января 1970 года 00:00:00 по UTC.

/* window, document */

const box = document.querySelector('.box');

// получаем ширину и высоту без учёта margin, border, scroll. показывают только видимую часть
box.clientWidth;
box.clientHeight;

// получаем ширину и высоту c учётом margin, padding, border, scroll. показывают только видимую часть
box.offsetWidth;
box.offsetHeight;

// получаем полность ширину и высоту элемента без учёта панелей scroll
box.scrollWidth;
const heigth = box.scrollHeight;

//вместо элемента можно прописать например document.documentElement.scrollHeight и мы получим высоту всего документа


btn.addEventListener('click', () => {
    box.style.heigth = heigth + 'px';
}); // при клике на кнопку раскрывает элемент полностью на всю высоту.

btn.addEventListener('click', () => {
    console.log(box.scrollTop);
}); // при клике на кнопку показывает сколько прокрутили от начала страницы

box.getBoundingClientRect(); //позволяет получить все коордунаты которые есть у элемента

const style = window.getComputedStyle(box); // позволяет получить все стили, которые установленны(применились) на данный элемент

window.scrollBy(x, y); // позволяет скроллить страницу относительно текущего положения
window.scrollTo(x, y); // позволяет скроллить страницу относительно начала страницы

window.pageYOffset; //позволяет понять сколько пикселей отличстал пользователь с начала страницы


/* Функции-конструкторы ES5*/

// Функции-конструкторы или конструкторы нужны для того чтобы создавать новые однотипные объекты. В пракике это могут быть например пользователи сайта, товары в магазине, видеоролики, компоненты сайта (слайдет и т.д.)
//Пример
function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello = function () {
        console.log(`Привет ${this.name}`);
    }
} // функция конструктор, которая поможет создавать разные объекты по этому шаблону. Имя Функции-конструктора всегда пишется с большой буквы. Также можешм прописывать методы

User.prototype.exit = function () {
    console.log(`Пользоваетль ${this.name} вышел`);
} // Также позвоялет задать новый метод Функции-конструктор через прототип, который смогуть использовать созданные объекты.

const ivan = new User('Ivan', 12);
const elena = new User('Elena', 25); // поместили в переменную новый объект с свойстави которые написаны в Функции-конструктор. Чтобы вызвать Функции-конструктор, надо писать new название Функции-конструктора, и передать нужные значения в функцию

ivan.exit(); // вызвваем метод, который прописали в прототипе

ivan.hello(); // вызываем метод, который был прописан в Функции-конструктора

/* Конетекст вызова. this */

function showThis() {
    console.log(this);
} // данная функция выдалст window если нет режима strict, если есть то выдаст undefined так как this должна привязываться к объекту, а функция должна быть его методом
// Обычная функция: this = window, но если use strict- undefined

function showThis(a, b) {
    console.log(this);

    function sum() {
        return this.a + this.b;
    }
} // если используется функция внутри функции то контекст не меняется и this будет равен undefined

const obj = {
    a: 20,
    b: 15,
    sum: function () {
        console.log(this); // выдаст весь объект
        function shout() {
            console.log(this);
        }
        shout(); // так как это простой вызов функции, то this выдаст undefined
    }
}
// Если используем метод внутри объекта, то this(контекст вызова) будет всегда ссылаться на объект
// Контекст у методов объекта - сам объект

function User(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello = function () {
        console.log(`Привет ${this.name}`);
    }
}

const egor = new User('Egor', 25);

// внутри функкции конструктора контекст вызова(this) всех методов и свойств будет только что созданный объект
// this в конструкторах и классах - это новый экземпляо объекта

//Ручное присвоение this любой функции
//Пример. Получение доступа к name для функции
function sayName() {
    console.log(this);
    console.log(this.name);
}

const user = {
    name: 'Jhon'
};

// разница только в синтаксисе, а так выдают тоже самое
sayName.call(user); // в скобках передаем контекст вызова который хотим передать функции
sayName.apply(user); // в скобках передаем контекст вызова который хотим передать функции
// функция приобрела свой контекст с помощью двух методов кторые записаны выше
// Если функция принимает дополнительные аргументы то запись становится такой:
sayName.call(user, 'аргумент', 'аргумент'); // аргументы передаются через запятую
sayName.apply(user, ['аргумент', 'аргумент']); // аргументы передаются в массиве через запятую

function count(num) {
    return this * num;
}
const double = count.bind(2); // передаем в контекст вызова 2. т.е. вместо this у нас будет 2. Так мы получаем новую функцию у которой жестко привязаный контекст
bind(); // создает новую функцию связанную с определенным контекстом
console.log(double(3)); // высываем функцию и передаем ей аргумент num. во время вызова функция выполнит действие: 2 * 3. так как this у нас 2
// ручная привязка this: call, apply, bind


btn.addEventListener('click', function () {
    console.log(this);
}); // при клике получем элемент на который кликнули. в данному случае на кнопку. Но это если функция написана в стандартном виде, т.е. не стрелочная. this здесь тоже самое, что и event.target

// у стрелочных функций нет своего контекста вызова, она его берет у родителя
const obj = {
    num: 5,
    sayNamber: function () {
        const say = () => {
            console.log(this); // в данном случае this будет ссылаться на объект, так как используем стрелочную функцию. в итоге выведет объект
        };

        say();
    }
}

btn.addEventListener('click', () => {
    console.log(this);
}); // если обработчике событий будет использовать стрелочную функцию, то this будет undefined. Использую стрелочные функции контект события теряется. Если в обработчике событий используем стрелочные функции, то лучше передавать аргумент event и не использовать this

/* Классы - это Синтаксический сахар */
// Классы красивая обёртка функции-костроктора
// часто используются для создания шаблонов
class Rectangle {
    constructor(height, width) {
        this.heigth = height;
        this.width = width;
    } // запятые в классе ставить не надо

    calcArea() {
        return this.heigth * this.width;
    }
}
// чтобы создать класс надо написать: class имяКласс {методы и свойста класса}
// чтобы в классе прописать свойста нужно написать так: constructor(аргументы, которые например могут приходить из вне) {здесь пишем свойства}
// методы пишутся: названиеМетода() {код} . Перед названием не надо писать function

class ColoredRectanglWidthText extends Rectangle {
    constructor(height, width, text, bgColor) {
        super(); // позволяет не прописывать заного свойства класса от которого наследуется данный класс. В общем получаем все свойста класса от которого наследуется данный класс и ниже можно дальше писать свойста для данного класса. всегда должен быть первым.
        this.text = text;
        this.bgColor = bgColor;
    }

    showMyPrors() {
        console.log(`текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}
// extends - позволяяет наследовать и использовать свойства и методы другого класса

/* Rest оператор и параметры по умолчанию */

const log = function (a, b = 1, ...rest) {
    console.log(a, b, rest);
} // ...rest - это возможные другие аргументы которых может быть очень много и возвращаются они в ввиде одно массива. даже если небыло введено ни одно другого аргумента после основных, то всё равно веренет массив, только пустой
// также аргументам мы можем задавать значения по умолчанию. в ES6 это делатется так: аргумент = значение по умолчанию. В ES5 делали присваивание с или: b = b || 1

/* JSON */

// json - используется для передачи и хранения данных
// json - это набор пар ключ: значение как и в объекте
// своего рода это небольшая База данных

const persone = {
    name: 'Alex',
    tel: '+744444444'
}
//напирмер нам надо передать данный объект на сервер. На прямую мы отправить не можем так как сервер и протокол передачи данных просто не поймут, поэтому надо превратить в один из вариантов чтобы можно было его транспортировать(передать)

JSON.stringify(persone); // преобразует в строку JSON, чтобы можно было передать на сервер и чтобы он понял что передали
// в json всё записано в парные кавычки

JSON.parse(JSON.stringify(persone)); // преобразует строку JSON, например которая пришла с сервера в обычный объект с которым можно дальше работать в JS

const clone = JSON.parse(JSON.stringify(persone)); // позволяет сделать полную копию объекта, т.е. копирует так же все вложенности которые есть в объекте. методы не копирует

/* AJAX. Общение с сервером */

const inputRub = document.querySelector('#rub');
const inputUsd = document.querySelector('#usd');

inputRub.addEventListener('input', () => {
    const request = new XMLHttpRequest(); // создаём XMLHttpRequest-объект

    request.open(method, url, asyns, login, pass); // вызвваем метод open(). собирает настройки, которые нужны для отправки запроса. принимает в себя несколько аргументов. 1) метод запроса (самые популярные GET и POST) GET - это получение данных. POST - отправка данных. 2) путь к серверу (может быть например файлик). Прописываем url по которому будем делать запрос. 3) отвечает на асинхронность. по умолчанию true. 4) некоторые запросы можно делать только если знаешь логин и пароль
    request.open('GET', 'js/current.json');
    // HTTP-заголовки -- позволяет сказать, что конкретно мы отправляем. какая информация, в чём закодирована. Делается для того чтобы трансферные протоколы понимали, что они передают и когда они предут с серверу, сервер точно понимал, что он принимает. (например это JSON файл, картинка, html и т.д.)
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); // заголовок который позволяет отправить json файл. Внутри указываем тип контента (в нашем случаем для json файла), плюс кодировку которую используем.
    request.send(); // метод который позволяет сделать отправку запроса на сервер. если используем метод GET то в скобачках ничего не пишем. Если будем использовать метод POST, то можно прописать тело запроса.

    // status - показывает статус нашего запроса (список кодов: https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
    // statusText - текстовое описание ответа от сервера
    // response - ответ от сервера
    // readyState - текущее состояние нашего запроса (https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState)

    request.addEventListener('readystatechange', () => { // readystatechange - используется редко
        if (request.readyState === 4 && request.status === 200) {
            console.log(request.response); // покажет, что пришло с сервера. тоесть результат запроса (объект json, который надо будет перевести в обычный объект, чтобы использовать), когда мы вводим, что-то в input
            const data = JSON.parse(request.response); // json-объект переводим в обычный объект, который можно использовать
            inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2); // вычисляем значения
        } // если статус готовности равен 4 (тоесть Операция полностью завершена и все данные пришли) и статус ответа равен 200 (тоесть ОК - хорошо, запрос успешно завершился). Можем выполнять действия на странице с данными которые пришли с сервера. Но перед этим первратить данные в обычные объекты
        else {
            inputUsd.value = 'Что-то пошло не так';
        } //всегда лучше показыавть, что пошло что-то не так. чтобы клиент например перезагрузил страницу и не ждал долго ответа
    }); // отслеживает собития статуса готовности нашего запроса в данный текущий момент. Следит за readyState

    // используем load
    request.addEventListener('load', () => { // load - страбатывает только один раз, когда запрос уже полность готов
        if (request.status === 200) {
            const data = JSON.parse(request.response);
            inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2);
        } else {
            inputUsd.value = 'Что-то пошло не так';
        }
    }); // отслеживает собития статуса готовности нашего запроса в данный текущий момент. Следит за readyState


}); // используем обработчик событий input, который позволяет сразу считывать введённую информацию в input. Получаем нужную инвормацию с сервера и используем её.
// XMLHttpRequest это API, который предоставляет клиенту функциональность для обмена данными между клиентом и сервером.


/* Промисы (Promise)(Обещание) */

console.log('Запрос данных...');

// callback hell
setTimeout(() => {
    console.log('Подготовка данных...');

    const product = {
        name: TV,
        price: 2000
    };

    setTimeout(() => {
        product.status = 'order';
        console.log(product)
    }, 2000);
}, 2000);
// чтобы не попадать в callback hell, нужно использовать промисы
// промисы позволяют улучшить порядок кода и дают нам гибкость

console.log('Запрос данных...');

const req = new Promise((resolve, reject) => {
    setTimeout(() => {
        console.log('Подготовка данных...');

        const product = {
            name: TV,
            price: 2000
        };
        // например мы получаем через 2 секунды объект и строку 'Подготовка данных...'. после этого выполняется resolve();
        resolve(product);
    }, 2000);
}); // колбек функция всегда принимает 2 аргумента, resolve и reject
// resolve означает, что что-то выполнилось правильно и отдаёт результат. Если сервер ответил то выполняется resolve()
// reject означает, что что-то пошло не так и выдаёт ошибку или ошибки. Если сервер не ответил или ответил с ошибкой, тоесть что-то пошло не так, то выполняется reject()
req.then((product) => {
    console.log('Данные получены');
    setTimeout(() => {
        product.status = 'order';
        console.log(product);
    }, 2000);
}); // Выполняется когда при выполнении промиса небыло ошибок и он выдал определенный результат и мы его передали сюда
// then(() => {}) обрабатывает положительные результаты. принимает аргумент с функцией, который называется resolve

// Допустим, что нужно сделать ещё несколько действий
req.then((product) => {
    const req2 = new Promise((resolve, reject) => {
        console.log('Данные получены');
        setTimeout(() => {
            product.status = 'order';
            resolve(product);
        }, 2000);
    });

    req2.then(data => {
        console.log(data);
    });
}); // данная запись не сильно отличается от callback hell

// преимущества промисов в том, что они могут промис then по цепочке. Асинхронная операция выполниться и начнётся следующая, которая будет использовать данные из результата прошлой или просто начнёт делать что-то другое
req.then((product) => { // принимает например данные от сервера
    return new Promise((resolve, reject) => { // возвращаем новый промис
        console.log('Данные получены');
        setTimeout(() => {
            product.status = 'order';
            resolve(product);
            // reject(); // будет выполняться если произошла ошибка
        }, 2000); // возвращаем промис, который выполнил асинхронную операцию. в итоге когда всё успешно мы выхываем resolve и возвращаем данные, которые пойдут дальше по операциям
    });
}).then(data => { // обробатываем любыми методами данные которые передал прошлый промис
    data.modify = true; // возвращать можем не только промисы
    return data;
}).then(data => {
    console.log(data); // если например опять надо будет работать с какой-то асинхронной операцией, то мы вернём от сюда промис и дальше его обработаем
}).catch(() => { // catch прописывается всегда в конце и выполниться если будет какая-то ошибка при выполнении
    console.error('Произошла ошибка');
}).finally(() => { // finally выполняется всегда. даже если вернулась ошибка
    console.log('Finally');
});
// с помощью промисов мы можем выполнять асинхронные операции по цепочке

const test = time => {
    return new Promise(resolve => {
        setTimeout(() => resolve(), time);
    });
}; // функция которая принимает количество времени, возвращает промис, который зарезолвится через определенное количество времени, которое мы передаем в эту функцию. Такую функцию можно использовать чтобы запускать одинаковые операции через определенный промежуток времени
test(1000).then(() => console.log('1000 ms')); // через 1 сек. покажет сообщение в консоле
test(2000).then(() => console.log('2000 ms')); // через 1 сек. покажет сообщение в консоле

Promise.all([test(1000), test(2000)]).then(() => {
    console.log('All');
}); // Данный метод принимает массив с промисами. Он ждет когда все промисы которые находятся в массиве выполнятся. После того как они вернут результат мы може его обработать

Promise.race([test(1000), test(2000)]).then(() => {
    console.log('All');
}); // Данный метод исполняется, когда хоть 1 промис выполнился (правильно отработал)


/* Fetch API */

// API - интерфейс какого-то праграмного обеспечения, либо приложения. Проще это набор данных и возможностей, которое предоставляет нам готовое решение.
// API — это не готовые решения, это среда, интерфейс для создания своих проектов. 
// API — это готовый код для упрощения жизни программисту. API создавался для того, чтобы программист реально мог облегчить задачу написания того или иного приложения благодаря использованию готового кода (например, функций).

// Fetch API - помогает общаться с сервером и постоена на промисах

fetch();

fetch('https://jsonplaceholder.typicode.com/todos/1') // делаем запрос. прописываем url куда делаем запрос. если больше ничего не указывать то это будет GET запрос. Возвращается промис
    .then(response => response.json()) // получает http-ответ и декодирует ответ в формате JSON. в итоге получаем промис, где значением будет обычный объект
    .then(json => console.log(json)); // выводим в консоль объект, который пришел с сервера

fetch('https://jsonplaceholder.typicode.com/posts/1', {
        method: 'POST',
        body: JSON.stringify({
            name: 'Alex'
        }), // в данном случае отправляем json данные. кроме объекста также можем поместить строку
        headers: {
            'Content-type': 'application/json'
        } // заголовки, чтобы определить какой контент мы отправляем
    }) // чтобы отправить запрос, нужно прописать url и объект в котороем есть несколько настроек, которые позволяют отправить запрос. в этом объеекте есть 2 обязаательных свойства: method и body(тело которое будем отправлять)
    .then(response => response.json()) // получает http-ответ и декодирует ответ в формате JSON. в итоге получаем промис, где значением будет обычный объект
    .then(json => console.log(json)); // выводим в консоль объект, который пришел с сервера

// Promise возвращаемый вызовом fetch() не перейдет в состояние "отклонено" из-за ответа HTTP, который считается ошибкой, даже если ответ HTTP 404 или 500.  Вместо этого, он будет выполнен нормально (с значением false в статусе ok ) и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
// catch() не вызовится даже если ответ HTTP 404 или 500. вызовится только при сбое сети или если что-то помешало запросу выполниться. такое поведение надо обработать вручную с помошью условий
if (!res.ok) { // например что-то посло не так, то выкидываем ошибку
    throw new Error(`Could not fetch ${url}, status ${res.status}`); // позволяет выкинуть новую ошибку, которую конструируем руками. Выведет статус ошибки и по какому url
}


/* Методы перебора массавов */

forEach // не создаёт новый массив, а просто перебирает и делает какие либо действия с элементами внутри массива

filter // фильтрует элементы внутри массива, по определённым параметрам(условиям)
// Пример отфильтровать имена которые меньше 5 символов. Возврашает новый массив. При это старый массив останется без изменений
const names = ['Ivan', 'Ann', 'Ksenia', 'Voldemart', ];

const shortNames = names.filter(function (name) { // name это каждый отдельный элемент внутри массива, который перебираем
    return name.length < 5; // вернёт элементы которые меньше 5 символов
});
console.log(shortNames); // выведет новый массив с именами которые меньше 5 символов

map // берет исходный массив и меняет элементы внутри него. на выходе получаем новый массив с измененными данными внутри массива
// Пример. допустив в именах буквы в разно регистре и хотим на выходе получить все имена в нижнем регистре
const answers = ['IvAn', 'AnnA', 'Hello'];

const result = answers.map(item => {
    return item.toLowerCase; // каждый элемент в массиве будет приведён в нижний регистр
}); // получим новый массив с элементами, коорые записаны в нижнем регистре
// также можем перезаписывать массив в туже переменную, а не создавать новую. Старый массив удалиться и заменится новым. Но лучше исходные даныне не перезаписывать и создавать с ними новые переменные

every / some // два метода которые возвращают булиновые значения
const some = [4, 'qweqwe', 'asdasdasd'];

console.log(some.some((item) => typeof (item) === 'number')); // спрашиваем есть ли стреди элементов в массиве число. Выведет true если хоть одни элемент в массиве удовлетворяет условию

console.log(some.every((item) => typeof (item) === 'number')); // спрашиваем есть ли стреди элементов в массиве число. Выведет true если все элементы в массиве удовлетворяют условию

reduce // служит для того чтобы схлопывать или собирать массив в одно единое целое. особенно это касается числовых данных
const arr = [4, 5, 1, 3, 2, 6];

const res = arr.reduce((sum, current) => sum + current, 3); // схлопываем массив одно значание. current это каждый элемент в массиве. sum в начале равно 0. выполняем своего рода цикл который складывает одно значение за другим. sum это значение одного цикла.
//В reduce вторым параметром можно задать начальное значение. в нашем примере это sum

const arr = ['apple', 'pear', 'plum'];

const res = arr.reduce((sum, current) => `${sum}, ${current}`); // sum это значение одного цикла. current это новый элемент


const obj = {
    ivan: 'persone',
    ann: 'persone',
    dog: 'animal',
    cat: 'animal'
};

const newArr = Object.entries(obj); // с помощью Object.entries() получаем новый массив и в нём находятся массивы [key, value] в которых находятся ключ: значения из объекта. Каждый ключ: значение это новый массив [key, value]

const persone = newArr.filter(item => item[1] === 'persone'); // вернёт новый массив в котором будут массивы, у которых есть значение persone.

const name = persone.map(item => item[0]); // получаем массив с именами

// также методы можно запускать по цепочке, чтобы не создавать каждый раз новые переменные
const newArr = Object.entries(obj)
    .filter(item => item[1] === 'persone')
    .map(item => item[0]); // в итогде получем тоже самое что и выше


/* async await */
// используются всегда в паре
// async говорит, что внутри функции будет асинхронный код
// await ставим перед теми операциями, которые нужно дождаться
// У слова async один простой смысл: эта функция всегда возвращает промис.
// ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.
// ключевое слово – await, которое можно использовать только внутри async-функций.


/* localStorage */

// localStorage позволяет сохранять данные на сайтах без Базы данных и работы с сервером, также хохраняет данные после перезагрузки страницы или закрытия браузера

// localStorage это объект который хранит ключ: значение
// localStorage объект существует в пределах одного домена и данные хранятся локально. вмешается в него 5 мегабайт информации

localStorage.setItem('number', 5); // принимает 2 аргумента. 1 аргумент это ключ, 2 аргумент это занчение. когда выполниться то в localStorage запишеться 2 аргумента. если такой ключ уже есть, то он перезапишется
localStorage.getItem('number'); // позволяет запросить из localStorage ключ, чтобы получить его значение. прописывать можно 1 аргумент и это ключ
localStorage.removeItem('number'); // позволяет удалить из localStorage ключ и значение. принимает название ключа
localStorage.clear(); // очищает полностью локально хранилище и не принимает аргументов

// Пример. Хотим сохранять значкние checkbox и какой цвет формы выбран
const checkbox = document.querySelector('#checkbox');
const form = document.querySelector('form');
const change = document.querySelector('#color');

if (localStorage.getItem('isChecked')) {
    checkbox.checked = true;
} // проверяем есть ли в localStorage isChecked. если да то при перезагрузке страницы у него будет значение true

if (localStorage.getItem('bg') === 'changed') {
    form.stile.backgroundColor = 'red';
} // проверяем есть ли в localStorage bg со значением changed. если да то при перезагрузке страницы backgroundColor будет red

checkbox.addEventListener('change', () => {
    localStorage.setItem('isChecked', true);
}); // записывает в localStorage isChecked со значением true

change.addEventListener('click', () => {
    if (localStorage.getItem('bg') === 'changed') {
        localStorage.removeItem('bg');
        form.stile.backgroundColor = '#fff';
    } else {
        localStorage.setItem('bg', 'changed');
        form.stile.backgroundColor = 'red';
    }
}); // записывает в localStorage bg со значением changed или удаляет его и меняет цвет фона формы при клике

const persone = {
    name: 'Alex',
    age: 25
} // допустим хотим сохранить объект об персонаже в localStorage

const serializedPersone = JSON.stringify(persone); // переводим в json формат
localStorage.setItem('alex', serializedPersone); // отправляем в localStorage ключ alex со значением serializedPersone в котором json объект. также можем из localStorage запросить json объект и работать с ним


/* Регулярные выражения */

// Регулярные выражения состоят из двух частей. Патерн(шаблон (например, что ищем в этой строке или что пытаемся удалить)) и флаги

new RegExp('pattern', 'flags'); // создание регулярного выражения с помощью конструктора. таким способом пользуются редко

/pattern/flags // такая запись намного короче и её используют очень часто

const ans = prompt('Введите ваше имя');

const reg = /n/ig; //допустим будем искать маленькую n
// три вида флагов
i // если хотим найти вне зависимости от регистра
g // если пытаемся найти несколько вхождений
m // включает многострочный режим

console.log(ans.search(reg)); // введя Ann в консоле выдаст 1 - это перва позиция по которой мы нашли n, а если afd то выведет -1
console.log(ans.match(reg)); // выдаст массив в котором кусок строки, который искали, индекс на котором был найден, сама строка по которой был совершен поиск. если стоит фоаг g то мы получим массив со всеми найдеными результатами. например вводим ANN и получим массив ["N", "N"]

const pass = prompt('Password'); // просим ввести пароль
console.log(pass.replace(/./g, "*")); // заменяем каждый символ на звёздочку. точка означает, что мы берем все элементы которые попадут в строку
console.log(pass.replace(/\./g, "*")); // чтобы взять только точку нодо экранировать с помощью знака \ и писать перед

console.log('12-34-56'.replace(/-/g, ':')); //заменяем тире на двоеточие

console.log(reg.test(ans)); // если найдет символ то выдаст true, если нет то false

// в регулярных выражениях есть классы
// \d это означает, что нужно искать все числа
// \w это озночает, что нужно искать все буквы
// \s это озночает, что нужно искать все пробелы

const ans = prompt('Введите число');
const reg = /\d/g; // будет искать все числа
console.log(ans.match(reg));

const str = 'my name is R2D2';
console.log(str.match(/\w\d\w\d/i)); // шаблон по которому будет искать в строке буква.число.буква.число в любом реегистре

// в регулярных выражениях есть также обратные классы
// \D это означает, что нужно искать не числа
// \W это озночает, что нужно искать не буквы
// \S это озночает, что нужно искать не пробелы


/* Аксессоры. get и set */

//Доступ к свойствам объекта представляют точечная и скобочная записи
object.property
object["property"]

// у объекта свойства делятса на свойства-данные и свойтсва-аксессоры

// Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются get и set

//Геттеры и сеттеры - свойства-аксессоры, которые представлены как методы в объекте, но обращаемся мы к ним, как к обычным свойствам.

// Геттер - нужен для чтения. get propName() {...}
// Сеттер - нужен для записи. set propName(value) {...}

// get позволяет получать значения свойства
// set позволяет устанавливать значения свойства

const obj = {
    name: 'Egor',
    age: 25,

    get nameAndAge() {
        return `${this.name} ${this.age}`;
    }, // при вызове данного свойства получим Egor 25

    set nameAndAge(value) {
        this.age = value;
    } // при вызове данного свойства и указании value мы изменим возраст в объекте
}

obj.nameAndAge; // возвращает то, что мы попросили его вернуть в фигурных скобках
obj.nameAndAge = 30; // позволяет заменять/устанавливать значения свойст в объекте.


/* Инкапсуляция */

// Инкапсуляция - это оделение и сокрытие свойств и методов объекта (в общем скрывает то, что не хотим чтобы меняли). В js это можно только имитировать.

// примеры
// функции-конструкторы
function User(name, age) {
    this.name = name;
    this.age = age;

    this.say = function () {
        console.log(`Имя: ${this.name}, возраст: ${this.age}`);
    }
}


const ivan = new User('Ivan', 25);
// наже можем получить доступ с свойствам и это нормальное поведение
console.log(ivan.name);
console.log(ivan.age);

ivan.age = 30; // также мы можем изменить свойство. и это может быть проблемой в будущем



//Прописываем Инкапсуляцию с псомощью создания переменной внутри конструктора
function User(name, age) {
    this.name = name;
    let userAge = age;

    this.say = function () {
        console.log(`Имя: ${this.name}, возраст: ${userAge}`);
    }

    this.getAge = function () {
        return userAge;
    } // метод который позволяет обратится к переменной userAge и вернуть значение

    this.setAge = function (age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            userAge = age;
        } else {
            console.log('недопустимое значение');
        }
    } // позволяет изменить переменную userAge из вне и проверить введёное значение из вне
}

ivan.userAge = 30; // если попробуем изменить значение таким способом то выдаст undefined и значение не поменяется
ivan.getAge(); // позволяет получить значение userAge
ivan.setAge(100); // позволяет сменить занчение userAge, если введённое число или символ удовлетворяет условию


// Инкапсуляция в классах
class User {
    constructor(name, age) {
        this.name = name;
        // let userAge = age; // доступа к ней внутри класса не будет
        // this.userAge = age; // но к сажелению это свойство теперь публично
        this._age = age; // используя синкакцис для свойства. Это _ перед названием свойства. Это не синтаксис языка, а соглашение программистов и говорит им, что такие свойста и методы не должны быть вызваны из вне. но есть программисты которые об этом не знают
    }

    say() {
        console.log(`Имя: ${this.name}, возраст: ${this._age}`);
    }

    get age() {
        return this._age;
    } // используем аксессор get

    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('недопустимое значение');
        }
    } // используем аксессор set
}


// Экспериментальная Инкапсуляция
class User {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }

    #surname = 'Zhidkov'; // создали приватное свойство с помощью #, которое можем использовать только внутри класа.

    say = () => {
        console.log(`Имя: ${this.name} ${this.#surname}, возраст: ${this._age}`); // здесь ещё обращаемся к свойству surname
    } // можем задать стрелочные функции, чтобы не терять контекст в некоторых случаях. this всегда будет ссыласться экземплят объекта

    get age() {
        return this._age;
    }

    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('недопустимое значение');
        }
    }

    get surname() {
        return this.#surname;
    }

    set age(surname) {
        this.#surname = surname;
    }
}
const egor = new User('Egor', 25);
console.log(egor.surname); // чтобы обратиться к свойству надо писать без #


/* Модули */

// есть 2 способа создания модуля

// 1) использовать анонимную самовызывающуюся функцию
const number = 1;

(function(){
    let number = 2;
    console.log(number);
    console.log(number + 3);
}()); //анонимная самовызывающуюся функция. анонимная потому-что нет имени, самовызывающаяся потому что она сразу вызывается на месте. Получается отдельный модуль со своей областью видимости

// 2) использование объектного интерфейса
// модуль записываем в переменную и в неё возвращаем метод, который будет доступен снаружи

const user = (function(){
    const privat = function() { // приватная функция к которой нет доступа из вне. потому что она лежит в локальной зоне видимости
        console.log('I am privat');
    }

    return {
        sayHello: privat
    } // из этой анонимной функции мы можем вернуть объект, где будут храниться методы и свойства, которые можно будет использовать снаружи
}());

user.sayHello(); // через метод sayHello мы вызвали приватную функцию. но изменить данную функцию из вне мы не можем



/* export, import. modulse ES6 */
// синтаксис ниже нужно собирать сборщиком модулей

// export - позволяет экспортировать различные данные. Чтобы экспортировать у каждой сущности должно быть имя
export let one = 1;

let two = 2;
export {two}; // обязательно в фигурных скобках. именной синтаксис

export function sayHi() {
    console.log('Hello');
}

// export default может быть только один в файле
export default function sayHi() {
    console.log('Hello');
}

// import
import {one as first, two} form './путь к файлу'; // в фигурных скобках пишем имена которые экспортировали. на как это именной синтаксис.
import * as data form './путь к файлу'; // импоритовали всё из файла, что было экспартировано в виде объекта и чтобы достучаться до переменных и функций надо писать например data.one или data.sayHi(). data - название которое мы задали
import sayHi from './путь к файлу'; // импортируем экспорт по умолчанию на прямую

// можно менять имя с помощью as
// one as first: one - название переменной, которую экспортировали. first - новое имя которое  задали при импорте

console.log(`${first} and ${two}`); // используем переменные которые импортировали в файл


/* try catch. Ошибки */

// если код в try произошла ошибка то выполниться catch и может сказать что произошла ошибка или просто оствами пустым, чтобы не говорил, что произошла ошибка. Но эта ошибка не остановит выполнение кода и код быдет выполняться дальше

try {
    // код
} catch(e) {}

console.log('normal');